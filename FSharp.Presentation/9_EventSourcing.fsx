(* 10. Event Sourcing 
    - Event sourcing system based on retail promotions
*)

type ProductId = string

type ZoneId = int

type PromotionEvent = 
    | Create of (string * ZoneId)
    | UpdateName of string
    | AddProduct of ProductId
    | RemoveProduct of ProductId
    | SetZone of ZoneId
    | Approve
    | Reject

type PromotionStatus = 
    | Draft
    | Approved

type PromotionState = {
    Name: string
    Products: Set<ProductId>
    ZoneId: ZoneId
    Status: PromotionStatus }
    with
    static member empty: PromotionState = {
        Name = ""
        Products = Set.empty<ProductId>
        ZoneId = 0
        Status = Draft }

let apply (state: PromotionState) (event: PromotionEvent) =
    match event with
    | Create (name, zoneId) -> {state with Name = name; ZoneId = zoneId}
    | UpdateName name -> {state with Name = name}
    | AddProduct id -> {state with Products = Set.add id state.Products}
    | RemoveProduct id -> {state with Products = Set.remove id state.Products}
    | SetZone id -> {state with ZoneId = id}
    | Approve ->
        match state.Status with
        | Draft -> {state with Status = Approved}
        | Approved -> state
    | Reject ->
        match state.Status with
        | Draft -> state
        | Approved -> {state with Status = Draft}

let replay events = Seq.fold apply PromotionState.empty events

// Long form of above function
let aggregateLong events = 
    let rec loop events state = 
        match events with
        | [] -> state
        | head::tail -> apply state head |> loop tail
    loop events PromotionState.empty
        
// These would be generated by a client application 
//  and persisted to a db
let testEvents = [
    Create ("My Promotion", 1);
    UpdateName "New PromotionName";
    AddProduct "Product1";
    AddProduct "Product2";
    RemoveProduct "Product1";
    Approve ]

let currentState = replay testEvents